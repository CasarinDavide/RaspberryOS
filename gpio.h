#pragma once 

#include "types.h"




/*


	----------------------------------------------------------

		The Device has three Auxiliary peripherals: One mini UART and two SPI masters. These
		three peripheral are grouped together as they share the same area in the peripheral register
		map and they share a common interrupt. Also all three are controlled by the auxiliary enable
		register.

		Is important to setup those register for starting working on the device for enables thing...
	---------------------------------------------------------


	1. AUX_IRQ (0x7E21 5000) 3bit size
	Function: Auxiliary Interrupt Status
	Description: This register contains status information for the interrupts generated by the auxiliary peripherals. It allows you to determine which auxiliary peripherals have pending interrupts.
	
	2. AUX_ENABLES (0x7E21 5004) 3bit size
	Function: Auxiliary Enables
	Description: This register is used to enable or disable the auxiliary peripherals. By setting bits in this register, you can enable the Mini UART and SPI interfaces.
	
	3. AUX_MU_IO_REG (0x7E21 5040) 8 bit size
	Function: Mini UART I/O Data
	Description: This register is used for sending and receiving data through the Mini UART. It’s an 8-bit data register that holds the data to be transmitted or received.
	
	4. AUX_MU_IER_REG (0x7E21 5044) 8 bit size
	Function: Mini UART Interrupt Enable
	Description: This register controls which Mini UART interrupts are enabled. You can enable or disable interrupts for data received, data transmitted, etc.
	
	5. AUX_MU_IIR_REG (0x7E21 5048) 8 bit size
	Function: Mini UART Interrupt Identification
	Description: This register provides information about the type of interrupt occurring on the Mini UART. It can be used to determine the cause of an interrupt.
	
	6. AUX_MU_LCR_REG (0x7E21 504C) 8 bit size
	Function: Mini UART Line Control
	Description: This register configures the Mini UART’s line control settings such as data format, parity, and number of stop bits.
	
	7. AUX_MU_MCR_REG (0x7E21 5050) 8 bit size
	Function: Mini UART Modem Control
	Description: This register is used to control the modem functions of the Mini UART. It can be used to manage signals like RTS (Request to Send) and DTR (Data Terminal Ready).
	
	8. AUX_MU_LSR_REG (0x7E21 5054) 8 bit size
	Function: Mini UART Line Status
	Description: This register provides status information about the Mini UART. It includes information about the availability of data and the status of the transmit and receive buffers.
	
	9. AUX_MU_MSR_REG (0x7E21 5058) 8 bit size
	Function: Mini UART Modem Status
	Description: This register provides status information related to modem signals.
	
	10. AUX_MU_SCRATCH (0x7E21 505C) 8 bit size
	Function: Mini UART Scratch
	Description: This is a general-purpose scratch register that can be used for temporary data storage.
	
	11. AUX_MU_CNTL_REG (0x7E21 5060) 8 bit size
	Function: Mini UART Extra Control
	Description: This register provides additional control options for the Mini UART, such as enabling or disabling the transmitter and receiver.
	
	12. AUX_MU_STAT_REG (0x7E21 5064) 32 bit size
	Function: Mini UART Extra Status
	Description: This register gives extra status information about the Mini UART, such as FIFO status.
	
	13. AUX_MU_BAUD_REG (0x7E21 5068) 16 bit size
	Function: Mini UART Baudrate
	Description: This register sets the baud rate (transmission speed) of the Mini UART. It’s used to configure the rate at which data is transmitted and received.
		
	*/

// used __attribute__ packed to ensure that compliers add padding to the struct
typedef struct {
    uint32 irq_status;
    uint32 enables;
    uint32 reserved[14];
    uint32 mu_io;
    uint32 mu_ier;	
    uint32 mu_iir;
    uint32 mu_lcr;
    uint32 mu_mcr;
    uint32 mu_lsr;
    uint32 mu_msr;
	uint32 mu_scratch;
	uint32 mu_control;
	uint32 mu_status;
	uint32 mu_baud_rate;

} __attribute__((packed)) auxiliary_register_map;


/**
 * 
    0x 7E20 0000 GPFSEL0 GPIO Function Select 0 32 R/W
	0x 7E20 0000 GPFSEL0 GPIO Function Select 0 32 R/W
	0x 7E20 0004 GPFSEL1 GPIO Function Select 1 32 R/W
	0x 7E20 0008 GPFSEL2 GPIO Function Select 2 32 R/W
	0x 7E20 000C GPFSEL3 GPIO Function Select 3 32 R/W
	0x 7E20 0010 GPFSEL4 GPIO Function Select 4 32 R/W
	0x 7E20 0014 GPFSEL5 GPIO Function Select 5 32 R/W
	0x 7E20 0018 - Reserved - -
	0x 7E20 001C GPSET0 GPIO Pin Output Set 0 32 W
	0x 7E20 0020 GPSET1 GPIO Pin Output Set 1 32 W
	0x 7E20 0024 - Reserved - -
	0x 7E20 0028 GPCLR0 GPIO Pin Output Clear 0 32 W
	0x 7E20 002C GPCLR1 GPIO Pin Output Clear 1 32 W
	0x 7E20 0030 - Reserved - -
	0x 7E20 0034 GPLEV0 GPIO Pin Level 0 32 R
	0x 7E20 0038 GPLEV1 GPIO Pin Level 1 32 R
	0x 7E20 003C - Reserved - -
	0x 7E20 0040 GPEDS0 GPIO Pin Event Detect Status 0 32 R/W
	0x 7E20 0044 GPEDS1 GPIO Pin Event Detect Status 1 32 R/W
	0x 7E20 0048 - Reserved - -
	0x 7E20 004C GPREN0 GPIO Pin Rising Edge Detect Enable 0 32 R/W
	0x 7E20 0050 GPREN1 GPIO Pin Rising Edge Detect Enable 1 32 R/W
	0x 7E20 0054 - Reserved - -
	0x 7E20 0058 GPFEN0 GPIO Pin Falling Edge Detect Enable 0 32 R/W
	0x 7E20 005C GPFEN1 GPIO Pin Falling Edge Detect Enable 1 32 R/W
	0x 7E20 0060 - Reserved - -
	0x 7E20 0064 GPHEN0 GPIO Pin High Detect Enable 0 32 R/W
	0x 7E20 0068 GPHEN1 GPIO Pin High Detect Enable 1 32 R/W
	0x 7E20 006C - Reserved - -
	0x 7E20 0070 GPLEN0 GPIO Pin Low Detect Enable 0 32 R/W
	0x 7E20 0074 GPLEN1 GPIO Pin Low Detect Enable 1 32 R/W
	0x 7E20 0078 - Reserved - -
	0x 7E20 007C GPAREN0 GPIO Pin Async. Rising Edge Detect 0 32 R/W
	0x 7E20 0080 GPAREN1 GPIO Pin Async. Rising Edge Detect 1 32 R/W
	0x 7E20 0084 - Reserved - -
	0x 7E20 0088 GPAFEN0 GPIO Pin Async. Falling Edge Detect 0 32 R/W
	0x 7E20 008C GPAFEN1 GPIO Pin Async. Falling Edge Detect 1 32 R/W
	0x 7E20 0090 - Reserved - -
	0x 7E20 0094 GPPUD GPIO Pin Pull-up/down Enable 32 R/W
	0x 7E20 0098 GPPUDCLK0 GPIO Pin Pull-up/down Enable Clock 0 32 R/W
	0x 7E20 009C GPPUDCLK1 GPIO Pin Pull-up/down Enable Clock 1 32 R/W
	0x 7E20 00A0 - Reserved - -
	0x 7E20 00B0 - Test 4 R/W 
 

 */


typedef struct 
{
	uint32 data;
} gpfsel;


typedef struct {
	gpfsel gpsel_reg[6];
	uint32 reserved;
	uint32 gpfset0;
	uint32 gpfset1;
	uint32 reserved_2;
	uint32 gpfclr0;
	uint32 gpfclr1;
	uint32 reserved_12;
	uint32 gpflev0;
	uint32 gpflev1;
	uint32 reserved_3;
	uint32 gplev0;
	uint32 gplev1;
	uint32 reserved_4;
	uint32 gpeds0;
	uint32 gpeds1;
	uint32 reserved_5;
	uint32 gpren0;
	uint32 gpren1;
	uint32 reserved_6;
	uint32 gpfen0;
	uint32 gpfen1;
	uint32 reserved_7;
	uint32 gphen0;
	uint32 gphen1;
	uint32 reserved_8;
	uint32 gplen0;
	uint32 gplen1;
	uint32 reserved_9;
	uint32 gpafen0;
	uint32 gpafen1;
	uint32 reserved_10;
	uint32 gppud;
	uint32 gppudclk0;
	uint32 gppudclk1;
	uint32 reserved_11;
	uint32 test;
}__attribute__((packed)) gpio; 

typedef enum{
	Input_state = 0,
	Output_state = 1,
	Alt_Fun_5_state = 2,
	Alt_Fun_4_state = 3,
	Alt_Fun_3_state = 7,
	Alt_Fun_0_state = 4,
	Alt_Fun_1_state = 5,
	Alt_Fun_2_state = 6
} GPIO_REG_STATE;


void writeFSel(volatile gpio* gpio_reg,uint32 register_number,GPIO_REG_STATE pin_state);
void execFsel(void (*f)(volatile gpio*), volatile gpio* gpio_reg,uint32 pin_number);
void offPUD(volatile gpio* gpio_reg);
void enablePullDownPUD(volatile gpio* gpio_reg);
void enablePullUpPUD(volatile gpio* gpio_reg);


